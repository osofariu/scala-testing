#+TITLE:    Testing in Scala
#+AUTHOR:   Ovi Sofariu
#+DATE:     July 11, 2016
#+EMAIL:    ovi@sofariu.com
#+HTML_HEAD: <link href="https://osofariu.github.io/css/solarized-light.css" rel="stylesheet"></link>
#+HTML_HEAD: <link href="https://osofariu.github.io/css/custom.css" rel="stylesheet"></link>
#+OPTIONS: H:2 num:nil toc:nil d:t *:t ':t \n:t @:t ::t |:t ^:nil _:nil

You can follow this presentation at: https://osofariu.github.io/preso/presentation.html

* SBT Setup

** Setting-up the project in build.sbt
#+begin_example
libraryDependencies ++=  Seq(
  "org.scalatest"  %% "scalatest" % "3.0.0-RC3" % "test" withSources() withJavadoc(),
  "org.scalactic"  %% "scalactic" % "3.0.0-RC3" % "test" withSources() withJavadoc(),
  "org.scalacheck" %% "scalacheck" % "1.13.0"   % "test" withSources() withJavadoc()
)
#+end_example

** Setting-up Super-safe
[[http://www.scalatest.org/supersafe][SuperSafe]] is a scala compiler plugin that catches certain issues at compile-time.

*** add plugin for super-safe in project/plugins.sbt
#+begin_example
addSbtPlugin("com.artima.supersafe" % "sbtplugin" % "1.1.0-RC7")
#+end_example

*** outside of the project, add resolver:
- If you want to import the project from GitHub into Intellij, *you need to do this step first*,
  so it can find the plugin when setting up the project.

#+begin_src sh
$ cd ~/.sbt/0.13
$ echo "resolvers += \"Artima Maven Repository\" at \"http://repo.artima.com/releases\"" >> global.sbt
#+end_src


* Running tests with SBT

** SBT basics
*** You can *chain* multiple commands to run tasks in batch mode, in sequential order:
#+begin_example
 sbt clean compile "testOnly TestA TestB"
#+end_example

*** You can continuously compile/test as you save your source files:
#+begin_example
 ~ compile , ~ test
 ~ testOnly *FunSpecSpec   // very useful when working on a spec
#+end_example
- this is very cool: you get instant feedback as soon as you save code changes
- I use it with IntelliJ, running sbt under IntelliJ terminal window

** SBT command-line arguments

| task           | description                                                                                   |
|----------------+-----------------------------------------------------------------------------------------------|
| clean          | Deletes all generated files (in the target directory).                                        |
| compile        | Compiles the main sources (in src/main/scala and src/main/java                                |
| test           | Compiles and runs all tests.                                                                  |
| console        | Starts the Scala interpreter with a classpath including compiled sources and all dependencies |
|                | To return to sbt, type :quit, Ctrl+D (Unix), or Ctrl+Z (Windows).                             |
| run <argument> | Runs the main class for the project in the same virtual machine as sbt.                       |
|                |                                                                                               |
| package        | Creates a jar file containing the files in src/main/resources and the                         |
|                | classes compiled from src/main/scala and src/main/java.                                       |
| reload         | Reloads the build definition (build.sbt, project/*.scala, project/*.sbt files).               |
|                | Needed if you change the build definition.                                                    |
| help <command> | Displays detailed help for the specified command.                                             |
|                | If no command is provided, displays brief descriptions of all commands.                       |

** SBT Tasks (from within sbt)
*** *test*
- The test task accepts no command line arguments and runs all tests

*** *testOnly*
- this task accepts a whitespace separated list of test names to run.
- before version 0.13 this task was "test-only". As of 0.13 they both work.

#+begin_example
testOnly testingscala.tags.FixtureWithSpec  testingscala.certaintests.TagSpec
#+end_example

- *use wildcards* to run only certain tests by name:
#+begin_example
testOnly *FixtureWithSpec
#+end_example

- **use tags** to only run certain tests by tag:

#+begin_example
testOnly *TagSpec -- -n FastTest  // only run tests tagged as "FastTest"
testOnly *TagSpec -- -n SlowTest -n FastTest // run both "SlowTest" and "FastTest" tags
testOnly *TagSpec -- -l SlowTest  // exclude tests tagged as "SlowTest"
testOnly *TagSpec -- -l SlowTest  // exclude these tags
#+end_example

*** *testQuick* - like testOnly, but also takes into account additional filters:
- The tests that failed in the previous run
- The tests that were not run before
- The tests that have one or more transitive dependencies, maybe in a different project,
  recompiled.


* ScalaTest

** Testing Styles
[[http://www.scalatest.org/user_guide/selecting_a_style]]

*** *FunSpec*
- Familiar to those who are used to rSpec.
- FunSpec allows you to nest your tests (like rSpec)

#+begin_src scala
  import org.scalatest.FunSpec

  class SetSpec extends FunSpec {

    describe("A Set") {
      describe("when empty") {
        it("should have size 0") {
          assert(Set.empty.size == 0)
        }

        it("should produce NoSuchElementException when head is invoked") {
          intercept[NoSuchElementException] {
            Set.empty.head
          }
        }
      }
    }
  }
#+end_src

Output:
#+begin_example
 A Set
   when empty
   - should have size 0
   - should produce NoSuchElementException when head is invoked
#+end_example

*Why is path.FunSpec is better than FunSpec?* See my _FunSpecSpec_ for an example that
demonstrates the difference

*** *FlatSpec*
- you can't next tests
- you use verbs like: must, should, can to make your tests more meaningful
- intuitive to use, but sometimes following the "subject should X" syntax is clumsy

#+begin_src scala
    import org.scalatest.FlatSpec

    class SetSpec extends FlatSpec {

      "An empty Set" should "have size 0" in {
        assert(Set.empty.size == 0)
      }

      it should "produce NoSuchElementException when head is invoked" in {
        intercept[NoSuchElementException] {
          Set.empty.head
        }
      }
    }
#+end_src

Output:
#+begin_example
An empty Set
- should have size 0
- should produce NoSuchElementException when head is invoked
#+end_example

*** *FreeSpec*
- Facilitates a BDD-style, in which tests are nested inside text clauses denoted with the
  dash operator (-).
- It enforces no structure, so you have maximum flexibility.

#+begin_src scala
import org.scalatest.FreeSpec

class StackSpec extends FreeSpec {
  "A Stack" - {
    "whenever it is empty" - {
      "certainly ought to" - {
        "be empty" in {
          // ...
        }
        "complain on peek" in {
          // ...
        }
        "complain on pop" in {
          // ...
        }
      }
    }
    "but when full, by contrast, must" - {
      "be full" in {
        // ...
      }
      "complain on push" in {
        // ...
      }
    }
  }
}

#+end_src

Output:
#+begin_example
StackSpec:
A Stack
  whenever it is empty
    certainly ought to
    - be empty
    - complain on peek
    - complain on pop
  but when full, by contrast, must
  - be full
  - complain on push
#+end_example

*** *WordSpec*
- Familiar to those who are used to specs or specs2

- Very prescriptive
- Quite a bit more wordy

#+begin_src scala
  import org.scalatest.WordSpec

  class SetSpec extends WordSpec {

    "A Set" when {
      "empty" should {
        "have size 0" in {
          assert(Set.empty.size == 0)
        }

        "produce NoSuchElementException when head is invoked" in {
          intercept[NoSuchElementException] {
            Set.empty.head
          }
        }
      }
    }
  }
#+end_src


#+begin_example
 SetTestWordSpec:
 A Set
   when empty
   - should have size 0
   - should produce NoSuchElementException when head is invoked

#+end_example

*** *Spec*

- It allows you to define tests as methods, which saves one function literal per test
  which translates into faster compile times and fewer generated class files, which can
  help minimize build times.

- Using Spec can be a good choice in large projects where build times are a concern as
  well as when generating large numbers of tests programmatically via static code
  generators.

#+begin_src scala
import org.scalatest.Spec

class SetSpec extends Spec {

  object `A Set` {
    object `when empty` {
      def `should have size 0` {
        assert(Set.empty.size == 0)
      }

      def `should produce NoSuchElementException when head is invoked` {
        intercept[NoSuchElementException] {
          Set.empty.head
        }
      }
    }
  }
}
#+end_src

#+begin_example
 A Set
   when empty
   - should have size 0
   - should produce NoSuchElementException when head is invoked
#+end_example

*** *FunSuite*
- For those who like xUnit-style tests

#+begin_src scala
  import org.scalatest.FunSuite

  class SetSuite extends FunSuite {

    test("An empty Set should have size 0") {
      assert(Set.empty.size == 0)
    }

    test("Invoking head on an empty Set should produce NoSuchElementException") {
      intercept[NoSuchElementException] {
        Set.empty.head
      }
    }
  }
#+end_src

Output:
#+begin_example
 - An empty Set should have size 0
 - Invoking head on an empty Set should produce NoSuchElementException
#+end_example

*** *PropSpec*

#+begin_src scala

  import org.scalatest._
  import prop._
  import scala.collection.immutable._

  class SetSpec extends PropSpec with TableDrivenPropertyChecks with Matchers {

    val examples =
      Table(
        "set",
        BitSet.empty,
        HashSet.empty[Int],
        TreeSet.empty[Int]
      )

    property("an empty Set should have size 0") {
      forAll(examples) { set =>
        set.size should be (0)
      }
    }

    property("invoking head on an empty set should produce NoSuchElementException") {
      forAll(examples) { set =>
         a [NoSuchElementException] should be thrownBy { set.head }
      }
    }
  }

#+end_src

Output:
#+begin_example
 - an empty Set should have size 0
 - invoking head on an empty set should produce NoSuchElementException
#+end_example

** Asserts/Inspectors
*** [[http://doc.scalatest.org/2.2.6/#org.scalatest.Inspectors][Inspectors]]

- Provides nestable inspector methods (or just inspectors) that enable assertions to be
  made about collections.

| forAll     |   | succeeds if the assertion holds true for every element                                     |
| forAtLeast |   | succeeds if the assertion holds true for at least the specified number of elements         |
| forAtMost  |   | succeeds if the assertion holds true for at most the specified number of elements          |
| forBetween |   | succeeds if the assertion holds true for between the specified minimum and maximum         |
|            |   | number of elements,  inclusive                                                             |
| forEvery   |   | same as forAll, but lists all failing elements if it fails (forAll just reports the first) |
| forExactly |   | succeeds if the assertion holds true for exactly the specified number of elements          |

#+begin_src scala
scala> import org.scalatest._
import org.scalatest._
scala> import Assertions._
import Assertions._

scala> import Inspectors._
import Inspectors._

scala> val xs = List(1, 2, 3, 4, 5)
xs: List[Int] = List(1, 2, 3, 4, 5)

#+end_src
*** [[http://doc.scalatest.org/2.2.6/#org.scalatest.Assertions][Assertions]]

#+begin_src scala
  import org.scalatest.Assertions._
  val left = 2
  val right = 1
  assert(left == right)
#+end_src

** ScalaTest in detail (with FunSpec)
*** how to ignore tests
**** Informers, Documenters, Notifiers, Alerters
- See: testingscala.report.ReportOnSpec 

**** Pending tests
- See: testingscala.certaintests.OmitSpec
  
**** Tagging tests
- See: testingscala.certaintests.TagSpec
  
**** Shared fixtures

- see if I can get this to work, to show the source:
#+!include ~/prog/projects/scala-testing/src/test/testingscala/fixtures/ExamplesWithFixture.scala

**** refactoring
**** get-fixture
**** fixture-context objects
**** withFixture(NoArgTest)
**** loan-fixture
**** withFixture(OneArgTest)
**** mixing in BeforeAndAfter
**** composing fixtures by stacking traits
**** Shared tests

**** two styles of asserts (demonstrate)


** Notes on Libraries

*** New in ScalaTest 3.0
- now fully support Scala.js
- *AsyncFunSuite*, *AsyncFunSpec*, *AsyncFlatSpec*, *AsyncFreeSpec*, *AsyncWordspec*, and
  *AsyncFeatureSpec* (the result type of tests is Future[Assertion])
- *oneElementOf*, *noElementsOf*, *atLeastOneElementOf*, *atMostOneElementOf*,
  *allElementsOf*, *inOrderElementsOf*
- Added overloaded *exists* and *forEvery* methods to TableDrivenPropertyChecks.
*** Scalactic
- In 2.2.0, org.scalautils has been renamed to org.scalactic (rhymes with "galactic").
- in 3.0 support Scala.JS
