#+TITLE:    Testing in Scala
#+AUTHOR:   Ovi Sofariu
#+DATE:     July 11, 2016
#+EMAIL:    ovi@sofariu.com
#+HTML_HEAD: <link href="https://osofariu.github.io/css/solarized-light.css" rel="stylesheet"></link>
#+HTML_HEAD: <link href="https://osofariu.github.io/css/custom.css" rel="stylesheet"></link>
#+OPTIONS: H:2 num:nil toc:nil d:t *:t ':t \n:t @:t ::t |:t ^:nil _:nil

You can follow this presentation at: https://osofariu.github.io/preso/presentation.html

* SBT Setup

** Setting-up the project in build.sbt
#+begin_example
libraryDependencies ++=  Seq(
  "org.scalatest"  %% "scalatest" % "3.0.0-RC3" % "test" withSources() withJavadoc(),
  "org.scalactic"  %% "scalactic" % "3.0.0-RC3" % "test" withSources() withJavadoc(),
  "org.scalacheck" %% "scalacheck" % "1.13.0"   % "test" withSources() withJavadoc()
)
#+end_example

** Setting-up Super-safe
[[http://www.scalatest.org/supersafe][SuperSafe]] is a scala compiler plugin that catches certain issues at compile-time.

*** add plugin for super-safe in project/plugins.sbt
#+begin_example
addSbtPlugin("com.artima.supersafe" % "sbtplugin" % "1.1.0-RC7")
#+end_example

*** outside of the project, add resolver:
#+begin_src sh
$ cd ~/.sbt/0.13
$ cat "resolvers += \"Artima Maven Repository\" at \"http://repo.artima.com/releases\"" >> global.sbt
#+end_src


* Running tests with SBT

** SBT basics
*** You can *chain* multiple commands to run tasks in batch mode, in sequential order:
#+begin_example
 sbt clean compile "testOnly TestA TestB"
#+end_example

*** You can continuously compile/test as you save your source files:
#+begin_example
 ~ compile , ~ test
 ~ testOnly *FunSpecSpec   // very useful when working on a spec
#+end_example
- this is very cool: you get instant feedback as soon as you save code changes
- I use it with IntelliJ, running sbt under IntelliJ terminal window

** SBT command-line arguments

| task           | description                                                                                   |
|----------------+-----------------------------------------------------------------------------------------------|
| clean          | Deletes all generated files (in the target directory).                                        |
| compile        | Compiles the main sources (in src/main/scala and src/main/java                                |
| test           | Compiles and runs all tests.                                                                  |
| console        | Starts the Scala interpreter with a classpath including compiled sources and all dependencies |
|                | To return to sbt, type :quit, Ctrl+D (Unix), or Ctrl+Z (Windows).                             |
| run <argument> | Runs the main class for the project in the same virtual machine as sbt.                       |
|                |                                                                                               |
| package        | Creates a jar file containing the files in src/main/resources and the                         |
|                | classes compiled from src/main/scala and src/main/java.                                       |
| reload         | Reloads the build definition (build.sbt, project/*.scala, project/*.sbt files).               |
|                | Needed if you change the build definition.                                                    |
| help <command> | Displays detailed help for the specified command.                                             |
|                | If no command is provided, displays brief descriptions of all commands.                       |
|                |                                                                                               |

** SBT Tasks (from within sbt)
*** *test*
- The test task accepts no command line arguments and runs all tests

*** *testOnly*
- this task accepts a whitespace separated list of test names to run.
- before version 0.13 this task was "test-only". As of 0.13 they both work.

#+begin_example
testOnly testingscala.tags.FixtureWithSpec  testingscala.tags.TagTest
#+end_example

- *use wildcards* to run only certain tests by name:
#+begin_example
testOnly *FixtureWithSpec
#+end_example

- **use tags** to only run certain tests by tag:

#+begin_example
testOnly *TagTest -- -n FastTest  // only run tests tagged as "FastTest"
testOnly *TagTest -- -n SlowTest -n FastTest // run both "SlowTest" and "FastTest" tags
testOnly *TagTest -- -l SlowTest  // exclude tests tagged as "SlowTest"
testOnly *TagTest -- -l SlowTest  // exclude these tags
#+end_example

*** *testQuick* - like testOnly, but also takes into account additional filters:
- The tests that failed in the previous run
- The tests that were not run before
- The tests that have one or more transitive dependencies, maybe in a different project,
  recompiled.


* ScalaTest

** Testing Styles
[[http://www.scalatest.org/user_guide/selecting_a_style]]

*** *FunSpec*
- Familiar to those who are used to Rpec.
- FunSpec allows you to nest your tests (like rspec)

#+begin_src scala
  import org.scalatest.FunSpec

  class SetSpec extends FunSpec {

    describe("A Set") {
      describe("when empty") {
        it("should have size 0") {
          assert(Set.empty.size == 0)
        }

        it("should produce NoSuchElementException when head is invoked") {
          intercept[NoSuchElementException] {
            Set.empty.head
          }
        }
      }
    }
  }
#+end_src

*Why is path.FunSpec is better than FunSpec?* See my _FunSpecSpec_ for an example that
demonstrates the difference

*** *FlatSpec*
- you can't next tests
- you use verbs like: must, should, can to make your tests more meaningful
- intuitive to use, but sometimes following the "subject should X" syntax is clumsy

#+begin_src scala
    import org.scalatest.FlatSpec

    class SetSpec extends FlatSpec {

      "An empty Set" should "have size 0" in {
        assert(Set.empty.size == 0)
      }

      it should "produce NoSuchElementException when head is invoked" in {
        intercept[NoSuchElementException] {
          Set.empty.head
        }
      }
    }
#+end_src

Output:
#+begin_example
An empty Set
- should have size 0
- should produce NoSuchElementException when head is invoked
#+end_example

*** *FreeSpec*
- Facilitates a BDD-style, in which tests are nested inside text clauses denoted with the
  dash operator (-).
- It enforces no structure, so you have maximum flexibility

#+begin_src scala
import org.scalatest.FreeSpec

class StackSpec extends FreeSpec {
  "A Stack" - {
    "whenever it is empty" - {
      "certainly ought to" - {
        "be empty" in {
          // ...
        }
        "complain on peek" in {
          // ...
        }
        "complain on pop" in {
          // ...
        }
      }
    }
    "but when full, by contrast, must" - {
      "be full" in {
        // ...
      }
      "complain on push" in {
        // ...
      }
    }
  }
}

#+end_src

Output:
#+begin_example
StackSpec:
A Stack
  whenever it is empty
    certainly ought to
    - be empty
    - complain on peek
    - complain on pop
  but when full, by contrast, must
  - be full
  - complain on push
#+end_example

*** *WordSpec*
- Familiar to those who are used to specs or specs2
- Very prescriptive
- Quite a bit more wordy

#+begin_src scala
  import org.scalatest.WordSpec

  class SetSpec extends WordSpec {

    "A Set" when {
      "empty" should {
        "have size 0" in {
          assert(Set.empty.size == 0)
        }

        "produce NoSuchElementException when head is invoked" in {
          intercept[NoSuchElementException] {
            Set.empty.head
          }
        }
      }
    }
  }
#+end_src


#+begin_example
 SetTestWordSpec:
 A Set
   when empty
   - should have size 0
   - should produce NoSuchElementException when head is invoked

#+end_example

*** *Spec*

#+begin_src scala
import org.scalatest.Spec

class SetSpec extends Spec {

  object `A Set` {
    object `when empty` {
      def `should have size 0` {
        assert(Set.empty.size == 0)
      }

      def `should produce NoSuchElementException when head is invoked` {
        intercept[NoSuchElementException] {
          Set.empty.head
        }
      }
    }
  }
}
#+end_src

*** *FunSuite*
- For those who like xUnit-style tests

#+begin_src scala
  import org.scalatest.FunSuite

  class SetSuite extends FunSuite {

    test("An empty Set should have size 0") {
      assert(Set.empty.size == 0)
    }

    test("Invoking head on an empty Set should produce NoSuchElementException") {
      intercept[NoSuchElementException] {
        Set.empty.head
      }
    }
  }
#+end_src

*** *PropSpec*

#+begin_src scala

import org.scalatest._
import prop._
import scala.collection.immutable._

class SetSpec extends PropSpec with TableDrivenPropertyChecks with Matchers {

  val examples =
    Table(
      "set",
      BitSet.empty,
      HashSet.empty[Int],
      TreeSet.empty[Int]
    )

  property("an empty Set should have size 0") {
    forAll(examples) { set =>
      set.size should be (0)
    }
  }

  property("invoking head on an empty set should produce NoSuchElementException") {
    forAll(examples) { set =>
       a [NoSuchElementException] should be thrownBy { set.head }
    }
  }
}
#+end_src


** Asserts/Inspectors
** [[http://doc.scalatest.org/2.2.6/#org.scalatest.Inspectors][Inspectors]]

| forAll     |   | succeeds if the assertion holds true for every element                                     |
| forAtLeast |   | succeeds if the assertion holds true for at least the specified number of elements         |
| forAtMost  |   | succeeds if the assertion holds true for at most the specified number of elements          |
| forBetween |   | succeeds if the assertion holds true for between the specified minimum and maximum         |
|            |   | number of elements,  inclusive                                                             |
| forEvery   |   | same as forAll, but lists all failing elements if it fails (forAll just reports the first) |
| forExactly |   | succeeds if the assertion holds true for exactly the specified number of elements          |


** [[http://doc.scalatest.org/2.2.6/#org.scalatest.Assertions][Assertions]]

#+begin_src scala
  import org.scalatest.Assertions._
  val left = 2
  val right = 1
  assert(left == right)
#+end_src

** ScalaTest (from other preso)

- interfaces with Junit and TestNG (demonstrate)
- two styles of asserts (demonstrate)
*** sharing
*** Scalactic
- In 2.2.0, org.scalautils has been renamed to org.scalactic (rhymes with "galactic").
- in 3.0 support Scala.JS
*** New in ScalaTest 3.0
- now fully support Scala.js
- AsyncFunSuite, AsyncFunSpec, AsyncFlatSpec, AsyncFreeSpec, AsyncWordspec, and AsyncFeatureSpec
  (the result type of tests is Future[Assertion])
- oneElementOf, noElementsOf, atLeastOneElementOf, atMostOneElementOf, allElementsOf, inOrderElementsOf
- Added overloaded exists and forEvery methods to TableDrivenPropertyChecks.
